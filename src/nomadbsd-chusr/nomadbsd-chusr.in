#!/usr/local/bin/python3.7
#
# Copyright (c) 2020 The NomadBSD Project. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from subprocess import Popen, PIPE
import os, re, sys

PROGRAM = '@PROGRAM@'
LOCALE_PATH = '@LOCALE_PATH@'

# Constants for the fields in a /etc/group record
GR_GROUP, GR_GID, GR_MEMBER = 0, 2, 3

# Constants for the fields in a /etc/master.passwd record
PW_USER, PW_UID, PW_GID, PW_CLASS, PW_GECOS, PW_SHELL = 0, 2, 3, 4, 7, 9

PATH_ETC_LOGIN  = '/etc/login.conf'
PATH_ETC_SHELLS = '/etc/shells'
PATH_ETC_GROUP  = '/etc/group'
PATH_ETC_MASTER_PASSWD = '/etc/master.passwd'

WINDOW_TITLE = 'Change user account'
WINDOW_WIDTH, WINDOW_HEIGHT = 600, 300

class Settings:
	def __init__(self):
		self.user    = None
		self.name    = None
		self.group   = None
		self.shell   = None
		self.lclass  = None
		self.sgroups = None

class MainWindow(QMainWindow):
	def __init__(self, *args, **kwargs):
		super(MainWindow, self).__init__(*args, **kwargs)

		self.changed = False
		self.passwd1_le = None
		self.passwd2_le = None
		self.settings = Settings()

		container = QWidget()
		layout = QVBoxLayout(container)

		icon = QIcon.fromTheme('icon_user')
		self.setWindowTitle(WINDOW_TITLE)
		self.setMinimumSize(WINDOW_WIDTH, WINDOW_HEIGHT)
		self.setWindowIcon(icon)
		self.setContentsMargins(10, 1, 10, 1)
		
		self.mk_status_widget()

		self.passwd_records = self.read_etc_passwd()
		self.group_records = self.read_etc_group()
		self.login_classes = self.read_login_conf()
	
		self.tabs = QTabWidget(self)
		self.tabs.addTab(self.gen_settings_tab(), self.tr('General settings'))
		self.tabs.addTab(self.password_tab(), self.tr('Password'))

		hbox = QHBoxLayout()
		del_pb  = QPushButton(self.tr('&Delete account'))
		save_pb = QPushButton(self.tr('&Save'))
		quit_pb = QPushButton(self.tr('&Quit'))

		hbox.addWidget(del_pb,  0, Qt.AlignLeft)
		hbox.addWidget(save_pb, 1, Qt.AlignRight)
		hbox.addWidget(quit_pb, 0, Qt.AlignRight)
		
		layout.addWidget(self.tabs)
		layout.addStretch(1)
		layout.addLayout(hbox)

		self.setCentralWidget(container)

		save_pb.clicked.connect(self.save_changes)
		del_pb.clicked.connect(self.delete_account)
		quit_pb.clicked.connect(self.quit)
		
	def closeEvent(self, event):
		self.quit()

	def password_tab(self):
		container = QWidget()
		layout = QVBoxLayout(container)
		form = QFormLayout()
		icon = QIcon.fromTheme('dialog-password')
		pic = QLabel()
		pic.setPixmap(icon.pixmap(64, 64))
		layout.addWidget(pic, 0, Qt.AlignLeft)

		self.passwd1_le = QLineEdit()
		self.passwd2_le = QLineEdit()
		self.passwd1_le.setEchoMode(QLineEdit.Password)
		self.passwd2_le.setEchoMode(QLineEdit.Password)

		form.addRow(QLabel(self.tr('Password:')), self.passwd1_le)
		form.addRow(QLabel(self.tr('Repeat password:')), self.passwd2_le)
		layout.addLayout(form)
		self.chpasswd_pb = QPushButton(self.tr('Change password'))
		self.chpasswd_pb.setEnabled(False)

		layout.addWidget(self.chpasswd_pb, 1, Qt.AlignRight)
		layout.addStretch(1)
		self.passwd1_le.textEdited.connect(self.compare_passwds)
		self.passwd2_le.textEdited.connect(self.compare_passwds)
		self.chpasswd_pb.clicked.connect(self.change_passwd)

		return container

	def compare_passwds(self):
		self.chpasswd_pb.setEnabled(False)
		if self.passwd1_le.text() != self.passwd2_le.text():
			self.set_status_msg(self.tr('Passwords do not match'))
		elif self.passwd1_le.text() == '':
			self.set_status_msg(self.tr('Password must not be empty'))
		else:
			self.chpasswd_pb.setEnabled(True)
			self.set_status_msg('')

	def change_passwd(self):
		proc = Popen(['pw', 'usermod', self.user_cbb.currentText(),
					  '-h', '0'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
		password = self.passwd1_le.text().encode()
		error = proc.communicate(input=password)[1]
		if proc.returncode != 0:
			self.errwin(self.tr('pw returned with an error'), error)
			sys.exit(1)
		self.set_status_msg(self.tr('Password successfully changed'))

	def gen_settings_tab(self):
		container = QWidget()
		layout = QVBoxLayout(container)
		form = QFormLayout()
		icon = QIcon.fromTheme('icon_user')

		self.user_cbb = self.mk_username_cbb()
		form.addRow(QLabel(self.tr('User:')), self.user_cbb)

		self.name_edit = QLineEdit()
		# Fields in the password files must not contain a ':'
		self.name_edit.setValidator(QRegExpValidator(QRegExp('[^:]+')))
		form.addRow(QLabel(self.tr('Name:')), self.name_edit)

		self.lgroup_cbb = self.mk_lgroup_cbb()
		form.addRow(QLabel(self.tr('Login group:')), self.lgroup_cbb)

		self.sgroup_le = QLineEdit()
		# Fields in the password files must not contain a ':'
		self.sgroup_le.setValidator(QRegExpValidator(QRegExp('[^:]+')))
		form.addRow(QLabel(self.tr('Secondary groups:')), self.sgroup_le)

		self.lclass_cbb = self.mk_lclass_cbb()
		form.addRow(QLabel(self.tr('Login class:')), self.lclass_cbb)
		
		self.shell_cbb = self.mk_shell_cbb()
		self.shell = form.addRow(QLabel(self.tr('Shell:')), self.shell_cbb)

		self.user_cbb_index = 0
		self.user_selected()
		pic = QLabel()
		pic.setPixmap(icon.pixmap(64, 64))
		layout.addWidget(pic, 0, Qt.AlignLeft)
		layout.addLayout(form)
		self.name_edit.textEdited.connect(self.catch_name_changed)
		self.sgroup_le.textEdited.connect(self.catch_sgroups_changed)

		self.user_cbb.activated.connect(self.user_selected)
		self.lgroup_cbb.currentIndexChanged.connect(self.catch_group_changed)
		self.shell_cbb.currentIndexChanged.connect(self.catch_shell_changed)
		self.lclass_cbb.currentIndexChanged.connect(self.catch_lclass_changed)
		return container

	def set_status_msg(self, text):
		self.status_msg.setText(text)

	def user_selected(self):
		if (self.user_cbb.currentIndex() == self.user_cbb_index and
		    self.changed):
			return
		if self.changed:
			DISCARD, CANCEL = 1, 2
			answer = self.qwin(self.tr('Discard changes?'),
							   self.tr('Changes have not been saved. Discard?'),
							   (self.tr('&Discard'), DISCARD),
							   (self.tr('&Cancel'),  CANCEL))

			if answer != DISCARD:
				self.user_cbb.setCurrentIndex(self.user_cbb_index)
				return
		record = self.get_pwd_record(self.user_cbb.currentText())
		if not record:
			return
		gstr = ', '.join(self.get_sgroup_list(record[PW_USER]))
		self.name_edit.setText(record[PW_GECOS])
		self.sgroup_le.setText(gstr)
	
		index = self.shell_cbb.findText(record[PW_SHELL].strip())
		self.shell_cbb.setCurrentIndex(index)
	
		index = self.lgroup_cbb.findText(self.group_from_gid(record[PW_GID]))
		self.lgroup_cbb.setCurrentIndex(index)
		if (record[PW_CLASS] == ''):
			record[PW_CLASS] = 'default'
		index = self.lclass_cbb.findText(record[PW_CLASS])
		self.lclass_cbb.setCurrentIndex(index)

		if self.passwd1_le != None:
			self.passwd1_le.setText('')
			self.passwd2_le.setText('')

		self.set_status_msg('')
		self.status_usr.setText('<b>' + record[PW_USER] + '</b>')
		self.setWindowTitle(WINDOW_TITLE + ' - ' + record[PW_USER])

		self.user_cbb_index   = self.user_cbb.currentIndex()
		self.settings.user    = record[PW_USER]
		self.settings.name    = record[PW_GECOS]
		self.settings.group   = self.group_from_gid(record[PW_GID])
		self.settings.lclass  = record[PW_CLASS]
		self.settings.shell   = record[PW_SHELL]
		self.settings.sgroups = gstr

		self.changed = False

	def mk_status_widget(self):
		container = QWidget()
		layout = QHBoxLayout(container)
		self.status_usr = QLabel()
		self.status_msg = QLabel()
		layout.addWidget(self.status_msg, 1, Qt.AlignRight)
		self.statusBar().insertPermanentWidget(0, self.status_usr, 0)
		self.statusBar().insertPermanentWidget(1, container, 1)

	def mk_username_cbb(self):
		cbb = QComboBox()
		for r in self.passwd_records:
			cbb.addItem(r[PW_USER])
		return cbb

	def mk_shell_cbb(self):
		cbb = QComboBox()
		f = open(PATH_ETC_SHELLS, 'r')
		for l in f:
			if l.startswith('/'):
				cbb.addItem(l.rstrip('\r\n').strip())
		# Finally, add the "nologin shell"
		cbb.addItem('/usr/sbin/nologin')
		f.close()
		return cbb

	def mk_lgroup_cbb(self):
		cbb = QComboBox()
		for r in self.group_records:
			cbb.addItem(r[GR_GROUP])
		return cbb

	def mk_lclass_cbb(self):
		cbb = QComboBox()
		for c in self.login_classes:
			cbb.addItem(c)
		return cbb

	def group_from_gid(self, gid):
		for r in self.group_records:
			if r[GR_GID] == gid:
				return r[GR_GROUP]

	def get_pwd_record(self, username):
		for r in self.passwd_records:
			if r[PW_USER] == username:
				return r

	def get_sgroup_list(self, username):
		groups = []
		for r in self.group_records:
			if username in r[GR_MEMBER].split(','):
				groups.append(r[GR_GROUP])
		return groups

	def read_login_conf(self):
		lclasses = []
		rx = re.compile('^([a-zA-Z_.+-]+)(\|.*)?:')
		f = open(PATH_ETC_LOGIN, 'r')
		for l in f:
			m = rx.match(l)
			if m:
				lclasses.append(m.group(1))
		f.close()
		return sorted(lclasses, key=lambda x: x[0])

	def read_etc_passwd(self):
		recs = [];
		f = open(PATH_ETC_MASTER_PASSWD, 'r')
		for l in f:
			if l.startswith('#'):
				continue
			fields = l.rstrip('\r\n').split(':')
			if int(fields[PW_UID]) != 0 and int(fields[PW_UID]) <= 1000:
				continue
			if fields[PW_USER] == 'nobody':
				continue
			recs.append(fields)
		f.close()
		return sorted(recs, key=lambda x: x[0])

	def read_etc_group(self):
		recs = []
		f = open(PATH_ETC_GROUP, 'r')
		for l in f:
			if l.startswith('\n') or l.startswith('#'):
				continue
			fields = l.rstrip('\r\n').split(':')
			recs.append(fields)
		f.close()
		return sorted(recs, key=lambda x: x[0])

	def qwin(self, title, text, *opts):
		buttons = []
		msg = QMessageBox(self)
		msg.setWindowModality(Qt.WindowModal)
		msg.setText(text)
		msg.setWindowTitle(title)
		msg.setIcon(QMessageBox.Warning)
		msg.setWindowIcon(QIcon(msg.iconPixmap()))

		for opt in opts:
			bt = msg.addButton(opt[0], QMessageBox.ActionRole)
			buttons.append((bt, opt[0], opt[1]))
		msg.exec_()
		clicked = msg.clickedButton()
		for b in buttons:
			if (b[0] == clicked):
				return b[2]

	def errwin_(self, title, text):
		msg = QMessageBox(self)
		msg.setWindowModality(Qt.WindowModal)
		msg.setText(text)
		msg.setWindowTitle(title)
		msg.setIcon(QMessageBox.Critical)
		msg.setWindowIcon(QIcon(msg.iconPixmap()))
		msg.exec_()

	def save_changes(self):
		if not self.changed:
			return
		# Verify sencondary group list
		for g in self.settings.sgroups.split(','):
			if not g:
				continue
			g = g.strip()
			if g not in [r[GR_GROUP].strip() for r in self.group_records]:
				self.errwin(self.tr('Unknown group'),
							self.tr('Unknown group "{0}"').format(g))
				return
		proc_args = ['pw', 'usermod', self.settings.user]
		if self.settings.name:
			proc_args.extend(['-c', self.settings.name])
		glist = self.settings.sgroups.replace(' ', '').strip(',')
		proc_args.extend(['-G', glist])
		if self.settings.lclass:
			proc_args.extend(['-L', self.settings.lclass])
		if self.settings.shell:
			proc_args.extend(['-s', self.settings.shell])
		proc = Popen(proc_args, stdin=PIPE, stdout=PIPE, stderr=PIPE)
		error = proc.communicate()[1]
		if proc.returncode != 0:
			self.errwin(self.tr('pw returned with an error'), error)
			sys.exit(1)
		self.changed = False
		self.set_status_msg(self.tr('Saved'))

	def delete_account(self):
		DELETE, CANCEL = 1, 2
		answer = self.qwin(self.tr('Sure to delete account?'),
						   self.tr('Are you sure you want to delete ' +
								   'the account for user {0}?')
								   .format(self.settings.user),
						   (self.tr('Delete account'), DELETE),
						   (self.tr('Cancel'), CANCEL))

		if answer != DELETE:
			return
		proc_args = ['pw', 'userdel', self.settings.user]
		index = self.user_cbb.findText(self.settings.user)
		if index < 0:
			return
		proc = Popen(proc_args, stdin=PIPE, stdout=PIPE, stderr=PIPE)
		error = proc.communicate()[1]
		if proc.returncode != 0:
			self.errwin(self.tr('pw returned with an error'), error)
			sys.exit(1)
		self.changed = False
		self.set_status_msg(self.tr('Account deleted'))
		self.user_cbb.removeItem(index)
		self.user_selected()

	def quit(self):
		if not self.changed:
			sys.exit(0)
		SAVE, QUIT, CANCEL = 1, 2, 3
		answer = self.qwin(self.tr('Really quit?'),
						   self.tr('Quit without saving?'),
						  (self.tr('&Save'), SAVE),
						  (self.tr('&Quit'), QUIT),
						  (self.tr('&Cancel'), CANCEL))
		if answer == CANCEL:
			return
		if answer == SAVE:
			self.save_changes()
		sys.exit(0)

	def set_changed(self):
		self.set_status_msg(self.tr('Modified'))
		self.changed = True

	def catch_name_changed(self):
		self.settings.name = self.name_edit.text()
		self.set_changed()

	def catch_shell_changed(self):
		self.settings.shell = self.shell_cbb.currentText()
		self.set_changed()

	def catch_group_changed(self):
		self.settings.group = self.lgroup_cbb.currentText()
		self.set_changed()

	def catch_lclass_changed(self):
		self.settings.lclass = self.lclass_cbb.currentText()
		self.set_changed()

	def catch_sgroups_changed(self):
		self.settings.sgroups = self.sgroup_le.text()
		self.set_changed()

def main():
	app = QApplication(sys.argv)
	translator = QTranslator()
	if (translator.load(QLocale(), PROGRAM, '_', LOCALE_PATH)):
		app.installTranslator(translator)
	if os.getuid() != 0 and os.geteuid() != 0:
		msg = QMessageBox()
		print(app.translate('QApplication',
							'Error: You must be root to run this program'))
		msg.setText(app.translate('QApplications',
								  'You must be root to run this program'))
		msg.setWindowTitle(app.translate('QApplication', 'Permission denied'))
		msg.setIcon(QMessageBox.Critical)
		msg.setWindowIcon(QIcon(msg.iconPixmap()))
		msg.exec_()
		sys.exit(77) # EX_NOPERM (sysexits(3))
	win = MainWindow()
	win.show()
	sys.exit(app.exec_())

if __name__ == '__main__':
	main()
